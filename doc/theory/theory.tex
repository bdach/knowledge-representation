\documentclass[11pt,a4paper]{article}
\usepackage{fullpage}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{float}
\usepackage{tabularx}
\usepackage[hidelinks]{hyperref}
\usepackage[polish]{babel}

\setlength{\parindent}{0cm}
\setlength{\parskip}{2mm}

\newtheorem{defn}{Definicja}

% definicje operatorów w zdaniach

\DeclareMathOperator{\Initially}{\textbf{\textit{initially}}}
\DeclareMathOperator{\After}{\textbf{\textit{after}}}
\DeclareMathOperator{\Observable}{\textbf{\textit{observable}}}
\DeclareMathOperator{\Causes}{\textbf{\textit{causes}}}
\DeclareMathOperator{\If}{\textbf{\textit{if}}}
\DeclareMathOperator{\Impossible}{\textbf{\textit{impossible}}}
\DeclareMathOperator{\Releases}{\textbf{\textit{releases}}}
\DeclareMathOperator{\Always}{\textbf{\textit{always}}}
\DeclareMathOperator{\Noninertial}{\textbf{\textit{noninertial}}}

\DeclareMathOperator{\Executable}{\textbf{\textit{executable}}}
\DeclareMathOperator{\Accessible}{\textbf{\textit{accessible}}}
\DeclareMathOperator{\Possibly}{\textbf{\textit{possibly}}}
\DeclareMathOperator{\Necessary}{\textbf{\textit{necessary}}}

\begin{document}

\title{Reprezentacja wiedzy \\
\Large{
    Projekt nr 4. --- Programy działań z akcjami współbieżnymi \\
    Podstawy teoretyczne
}}
\author{
    Bartłomiej Dach \and
    Jacek Dziwulski \and
    Tymon Felski \and
    Jędrzej Fijałkowski \and
    Filip Grajek \and
    Maciej Grzeszczak \and
    Michał Kołodziej \and
    Piotr Piwowarski \and
    Mateusz Rymuszka \and
    Piotr Wolski
}
\maketitle

\section{Założenia}

Dana jest klasa systemów dynamicznych spełniających następujące warunki:

\begin{enumerate}
    \item Prawo inercji.
    \item Niedeterminizm.
    \item W języku kwerend występują akcje złożone (zbiory co najwyżej $k$ akcji atomowych), w~języku akcji jedynie akcje atomowe.
    \item Pełna informacja o~wszystkich akcjach atomowych i~wszystkich ich skutkach bezpośrednich.
    \item Z~każdą akcją atomową związany jest jej warunek wstępny (ew. \textsc{True}) i~końcowy (efekt akcji).
    \item Wykonywane są jedynie akcje bezkonfliktowe (żadne dwie akcje składowe nie~mogą mieć wspólnych zmiennych, na~które w~żadnym stanie mają wpływ).
    \item Wynikiem akcji złożonej jest suma skutków wszystkich składowych akcji bezkonfliktowych.
    \item Akcje mogą być niewykonalne w~pewnych stanach; jeśli akcja jest niewykonywalna, to~każda akcja ją zawierająca też jest niewykonalna.
    \item Dopuszczalny jest opis częściowy zarówno stanu początkowego, jak i~pewnych stanów wynikających z~wykonań sekwencji akcji.
\end{enumerate}

\begin{defn}
    \textbf{Programem $P$ działań} jest ciąg $P = (A_1, \dots,A_n)$ akcji złożonych.
\end{defn}

\begin{defn}
    Program $P = (A_1, \dots, A_n)$ jest \textbf{realizowalny}, jeśli wszystkie akcje złożone $A_i$ są~wykonalne.
\end{defn}

Celem projektu jest opracowanie i~zaimplementowanie języka akcji dla~specyfikacji podanej klasy systemów dynamicznych oraz~odpowiadającego mu języka kwerend zapewniającego uzyskanie odpowiedzi na następujące zapytania:

\begin{enumerate}
    \item Czy podany program $P$ działań jest możliwy do~realizacji zawsze/kiedykolwiek ze stanu początkowego?
    \item Czy wykonanie programu $P$ w~stanie początkowym działań prowadzi zawsze/kiedykolwiek do~osiągnięcia celu~$\gamma$?
    \item Czy cel~$\gamma$ jest osiągalny ze~stanu początkowego?
\end{enumerate}

% TODO: definicja struktury, formuły

\section{Język akcji}

\subsection{Składnia języka}

Język opracowany w~ramach projektu będzie bazować na~językach z~rodziny $\mathcal{AR}$.

\begin{defn}
    \textbf{Sygnaturą} języka jest uporządkowana para zbiorów $\Upsilon = (\mathcal{F}, \mathcal{A}c)$, gdzie $\mathcal{F}$ to~zbiór fluentów, a $ \mathcal{A}c$ to~zbiór akcji. Dodatkowo definiuje~się zbiór \textbf{fluentów inercjalnych} $\mathcal{F}_I \subseteq \mathcal{F}$.
\end{defn}

\begin{defn}
    \textbf{Formuła} nad~zbiorem fluentów~$\mathcal{F}$ to~dowolny predykat zbudowany z~fluentów: 
    $$ \alpha ::= f\ |\ \neg\alpha\ |\ \alpha_1 \land \alpha_2\ |\ \alpha_1 \lor \alpha_2\ |\ \alpha_1 \rightarrow \alpha_2\ |\ \alpha_1 \leftrightarrow \alpha_2 $$
    Ponadto definiujemy dwie specjalne formuły:
    
    \begin{itemize}
    \item $\top\colon$ prawda,
    
    \item $\bot\colon$ fałsz.
    \end{itemize}
    
    Zbiór wszystkich formuł nad~zbiorem fluentów $\mathcal{F}$ oznaczamy jako $Forms(\mathcal{F})$.
\end{defn}

W języku istnieje pięć rodzajów zdań:
\begin{enumerate}
    \item Zdania wartości:
    \begin{itemize}
        \item $\Initially \alpha$ -- określa, że w~stanie początkowym formuła~$\alpha$ musi być spełniona,
        \item $\alpha \After A$ -- formuła~$\alpha$ musi być spełniona po~wykonaniu akcji~$A$,
        \item $\Observable \alpha \After A$ -- formuła~$\alpha$ może (ale nie~musi) być spełniona po~wykonaniu akcji~$A$,
    \end{itemize}
        
    gdzie $\alpha \in Forms(\mathcal{F})$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania efektu:
    \begin{itemize}
        \item $A \Causes \alpha \If \pi$ -- wykonanie akcji $A$ w~dowolnym stanie spełniającym~$\pi$ daje efekt~$\alpha$,
        \item $A \Causes \alpha$ -- wykonanie akcji $A$ w~każdym stanie daje efekt~$\alpha$,
        \item $\Impossible A \If \pi$ -- akcja $A$ jest niewykonalna w~każdym stanie spełniającym $\pi$,
    \end{itemize}
    
    gdzie $\alpha, \pi \in Forms(\mathcal{F})$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania uwolnienia fluentu:
    \begin{itemize}
        \item $A \Releases f \If \pi$ -- wykonanie akcji~$A$ w~dowolnym stanie spełniającym~$\pi$ może, ale nie~musi zmienić wartości fluentu inercjalnego~$f$,
        \item $A \Releases f$ -- wykonanie akcji~$A$ w~każdym stanie może, ale nie~musi zmienić wartości fluentu inercjalnego~$f$,
    \end{itemize}
    
    gdzie $\pi \in Forms(\mathcal{F})$, $f \in \mathcal{F}_I$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania ograniczenia:
    \begin{itemize}
        \item $\Always \alpha$ -- formuła $\alpha$ jest spełniona w~każdym stanie,
    \end{itemize}
    gdzie $\alpha \in Forms(\mathcal{F})$.
    
    \item Zdania specyfikacji fluentu:
    \begin{itemize}
        \item $\Noninertial f$ - oznacza fluent $f$ jako nieinercjalny,
    \end{itemize}
    gdzie $f \notin \mathcal{F}_I$.
    
\end{enumerate}

\subsection{Semantyka języka}

\section{Język kwerend}

\subsection{Składnia języka}

    \textbf{Kwerendą} będziemy nazywać jedno z~następujących wyrażeń:

    \begin{enumerate}
        \item Kwerendy wartości:
        \begin{itemize}            
            \item $\Possibly \gamma \After A_1, \dots, A_n$ -- określa, czy wykonanie programu $(A_1, \dots, A_n)$ ze~stanu początkowego prowadzi kiedykolwiek do~osiągnięcia celu~$\gamma$,
            \item $\Necessary \gamma \After A_1, \dots, A_n$ -- określa, czy wykonanie programu $(A_1, \dots, A_n)$ ze~stanu początkowego zawsze prowadzi do~osiągnięciu celu~$\gamma$,
        \end{itemize}
        \item Kwerendy wykonywalności:
        \begin{itemize}
            \item $\Executable A_1, \dots, A_n$ -- określa, czy program $(A_1, \dots, A_n)$ jest kiedykolwiek wykonywalny ze~stanu początkowego,
            \item $\Executable \Always A_1, \dots, A_n$ -- określa, czy program $(A_1, \dots, A_n)$ jest zawsze wykonywalny ze~stanu początkowego,
        \end{itemize}
        gdzie $A_1, \dots, A_n \subseteq \mathcal{A}c$.
        \item Kwerendy osiągalności:
        \begin{itemize}
            \item $\Accessible \gamma$ -- określa, czy~istnieje taki program $(A_1, \dots, A_n)$, $n \geq 0$ wykonywalny ze~stanu początkowego, po~którego wykonaniu osiągnięty zostanie cel~$\gamma$.
        \end{itemize}
        gdzie $\gamma \in Forms(f)$, $A_1, \dots, A_n \subseteq \mathcal{A}c$.
    \end{enumerate}


\subsection{Semantyka języka}

\section{Przykładowe kwerendy}

\end{document}