\documentclass[11pt,a4paper]{article}
\usepackage{fullpage}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{float}
\usepackage{tabularx}
\usepackage[hidelinks]{hyperref}
\usepackage[polish]{babel}

\setlength{\parindent}{0cm}
\setlength{\parskip}{2mm}

\newtheorem{defn}{Definicja}
\newtheorem{theorem}{Twierdzenie}

% definicje operatorów w zdaniach

\DeclareMathOperator{\Initially}{\textbf{\textit{initially}}}
\DeclareMathOperator{\After}{\textbf{\textit{after}}}
\DeclareMathOperator{\Observable}{\textbf{\textit{observable}}}
\DeclareMathOperator{\Causes}{\textbf{\textit{causes}}}
\DeclareMathOperator{\If}{\textbf{\textit{if}}}
\DeclareMathOperator{\Impossible}{\textbf{\textit{impossible}}}
\DeclareMathOperator{\Releases}{\textbf{\textit{releases}}}
\DeclareMathOperator{\Always}{\textbf{\textit{always}}}
\DeclareMathOperator{\Noninertial}{\textbf{\textit{noninertial}}}

\DeclareMathOperator{\Executable}{\textbf{\textit{executable}}}
\DeclareMathOperator{\Accessible}{\textbf{\textit{accessible}}}
\DeclareMathOperator{\Possibly}{\textbf{\textit{possibly}}}
\DeclareMathOperator{\Necessary}{\textbf{\textit{necessary}}}

\def\consequence{\mathrel|\joinrel\approx}

\begin{document}

\title{Reprezentacja wiedzy \\
\Large{
    Projekt nr 4. --- Programy działań z akcjami współbieżnymi \\
    Podstawy teoretyczne
}}
\author{
    Bartłomiej Dach \and
    Jacek Dziwulski \and
    Tymon Felski \and
    Jędrzej Fijałkowski \and
    Filip Grajek \and
    Maciej Grzeszczak \and
    Michał Kołodziej \and
    Piotr Piwowarski \and
    Mateusz Rymuszka \and
    Piotr Wolski
}
\maketitle

\section{Założenia}

Dana jest klasa systemów dynamicznych spełniających następujące warunki:

\begin{enumerate}
    \item Prawo inercji.
    \item Niedeterminizm.
    \item W języku kwerend występują akcje złożone (zbiory co najwyżej $k$ akcji atomowych), w~języku akcji jedynie akcje atomowe.
    \item Pełna informacja o~wszystkich akcjach atomowych i~wszystkich ich skutkach bezpośrednich.
    \item Z~każdą akcją atomową związany jest jej warunek wstępny (ew. \textsc{True}) i~końcowy (efekt akcji).
    \item Wykonywane są jedynie akcje bezkonfliktowe (żadne dwie akcje składowe nie~mogą mieć wspólnych zmiennych, na~które w~żadnym stanie mają wpływ).
    \item Wynikiem akcji złożonej jest suma skutków wszystkich składowych akcji bezkonfliktowych.
    \item Akcje mogą być niewykonalne w~pewnych stanach; jeśli akcja jest niewykonywalna, to~każda akcja ją zawierająca też jest niewykonalna.
    \item Dopuszczalny jest opis częściowy zarówno stanu początkowego, jak i~pewnych stanów wynikających z~wykonań sekwencji akcji.
\end{enumerate}

\begin{defn}
    \textbf{Programem $P$ działań} jest ciąg $P = (A_1, \dots,A_n)$ akcji złożonych.
\end{defn}

\begin{defn}
    Program $P = (A_1, \dots, A_n)$ jest \textbf{realizowalny}, jeśli wszystkie akcje złożone $A_i$ są~wykonalne.
\end{defn}

Celem projektu jest opracowanie i~zaimplementowanie języka akcji dla~specyfikacji podanej klasy systemów dynamicznych oraz~odpowiadającego mu języka kwerend zapewniającego uzyskanie odpowiedzi na następujące zapytania:

\begin{enumerate}
    \item Czy podany program $P$ działań jest możliwy do~realizacji zawsze/kiedykolwiek ze stanu początkowego?
    \item Czy wykonanie programu $P$ w~stanie początkowym działań prowadzi zawsze/kiedykolwiek do~osiągnięcia celu~$\gamma$?
    \item Czy cel~$\gamma$ jest osiągalny ze~stanu początkowego?
\end{enumerate}

\section{Język akcji}

\subsection{Składnia języka}

Język opracowany w~ramach projektu będzie bazować na~językach z~rodziny $\mathcal{AR}$.

\begin{defn}
    \textbf{Sygnaturą} języka jest uporządkowana para zbiorów $\Upsilon = (\mathcal{F}, \mathcal{A}c)$, gdzie $\mathcal{F}$ to~zbiór fluentów, a $ \mathcal{A}c$ to~zbiór akcji. Dodatkowo definiuje~się zbiór \textbf{fluentów inercjalnych} $\mathcal{F}_I \subseteq \mathcal{F}$.
\end{defn}

\begin{defn}
    \textbf{Formuła} nad~zbiorem fluentów~$\mathcal{F}$ to~dowolny predykat zbudowany z~fluentów: 
    $$ \alpha ::= f\ |\ \neg\alpha\ |\ \alpha_1 \land \alpha_2\ |\ \alpha_1 \lor \alpha_2\ |\ \alpha_1 \rightarrow \alpha_2\ |\ \alpha_1 \leftrightarrow \alpha_2 $$
    Ponadto definiujemy dwie specjalne formuły:
    
    \begin{itemize}
    \item $\top\colon$ prawda,
    
    \item $\bot\colon$ fałsz.
    \end{itemize}
    
    Zbiór wszystkich formuł nad~zbiorem fluentów $\mathcal{F}$ oznaczamy jako $Forms(\mathcal{F})$.
\end{defn}

W języku istnieje pięć rodzajów zdań:
\begin{enumerate}
    \item Zdania wartości:
    \begin{itemize}
        \item $\Initially \alpha$ -- określa, że w~stanie początkowym formuła~$\alpha$ musi być spełniona,
        \item $\alpha \After A$ -- formuła~$\alpha$ musi być spełniona po~wykonaniu akcji~$A$,
        \item $\Observable \alpha \After A$ -- formuła~$\alpha$ może (ale nie~musi) być spełniona po~wykonaniu akcji~$A$,
    \end{itemize}
        
    gdzie $\alpha \in Forms(\mathcal{F})$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania efektu:
    \begin{itemize}
        \item $A \Causes \alpha \If \pi$ -- wykonanie akcji $A$ w~dowolnym stanie spełniającym~$\pi$ daje efekt~$\alpha$,
        \item $A \Causes \alpha$ -- wykonanie akcji $A$ w~każdym stanie daje efekt~$\alpha$,
        \item $\Impossible A \If \pi$ -- akcja $A$ jest niewykonalna w~każdym stanie spełniającym $\pi$,
    \end{itemize}
    
    gdzie $\alpha, \pi \in Forms(\mathcal{F})$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania uwolnienia fluentu:
    \begin{itemize}
        \item $A \Releases f \If \pi$ -- wykonanie akcji~$A$ w~dowolnym stanie spełniającym~$\pi$ może, ale nie~musi zmienić wartości fluentu inercjalnego~$f$,
        \item $A \Releases f$ -- wykonanie akcji~$A$ w~każdym stanie może, ale nie~musi zmienić wartości fluentu inercjalnego~$f$,
    \end{itemize}
    
    gdzie $\pi \in Forms(\mathcal{F})$, $f \in \mathcal{F}_I$ oraz $A \in \mathcal{A}c$.
    
    \item Zdania ograniczenia:
    \begin{itemize}
        \item $\Always \alpha$ -- formuła $\alpha$ jest spełniona w~każdym stanie,
    \end{itemize}
    gdzie $\alpha \in Forms(\mathcal{F})$.
    
    \item Zdania specyfikacji fluentu:
    \begin{itemize}
        \item $\Noninertial f$ - oznacza fluent $f$ jako nieinercjalny,
    \end{itemize}
    gdzie $f \notin \mathcal{F}_I$.
    
\end{enumerate}

\subsection{Semantyka języka}

\begin{defn}
Stanem nazywamy funkcję $\sigma : \mathcal{F} \rightarrow \left\{0,1\right\}$.
\end{defn}
Dodatkowo, przez $\sigma^{*}$ określamy rozszerzenie tej funkcji, zdefiniowane dla wszystkich formuł nad zbiorem fluentów:
$$\sigma^{*} : Forms(\mathcal{F}) \rightarrow \left\{0,1\right\}$$
gdzie:
$$\sigma^{*}\left(f\right) = \sigma\left(f\right) \text{ dla } f \in \mathcal{F}$$
$$\sigma^{*}\left(\neg \alpha\right) = 1 - \sigma^{*}\left(\alpha\right)$$
$$\sigma^{*}\left(\alpha \land \beta\right) = min\left(\sigma^{*}\left(\alpha\right),\sigma^{*}\left(\beta\right)\right)$$
$$\sigma^{*}\left(\alpha \lor \beta\right) = max\left(\sigma^{*}\left(\alpha\right),\sigma^{*}\left(\beta\right)\right)$$
$$\sigma^{*}\left(\alpha \rightarrow \beta\right) = \sigma^{*}\left(\neg \alpha \lor \beta\right)$$
$$\sigma^{*}\left(\alpha \equiv \beta\right) = \sigma^{*}\left(\left(\alpha \rightarrow \beta\right)\land\left(\beta \rightarrow \alpha\right)\right)$$

Dla każdej formuły $\alpha \in Forms\left(\mathcal{F}\right)$, gdy $\sigma^*\left(\alpha\right) = 1$, piszemy $\sigma^{*} \models \alpha$. 

W dalszej części dokumentu będziemy pisać $\sigma\left(\alpha\right)$ zamiast $\sigma^*\left(\alpha\right)$.

\begin{defn}
Strukturą dla języka $\mathcal{L}$ nazywamy trójkę
$$\mathcal{S} = \left(\Sigma, \sigma_0, Res\right)$$
gdzie:
\begin{enumerate}
    \item $\Sigma$ - zbiór stanów spełniających wszystkie ograniczenia
    \item $\sigma_0 \in \Sigma$ - stan poczatkowy
    \item $Res : 2^{Ac} \times \Sigma \rightarrow 2^\Sigma$ - funkcja przejścia
\end{enumerate}
\end{defn}

Dla każdego zbioru akcji $A \in 2^{Ac}$ i dla każdego stanu $\sigma \in \Sigma$, $Res$ przyporządkowuje zbiór stanów możliwych do osiągnięcia przez wykonanie zbioru $A$ w stanie $\sigma$.

Dodatkowo przez $Res\left(\left(A_1,A_2,\dots,A_n\right),\sigma\right)$ gdzie $A_1,A_2,\dots,A_n \in 2^{Ac}$ oznaczamy zbiór stanów możliwych do osiągnięcia po wykonaniu ciągu zbiorów akcji $A_1,A_2,\dots,A_n$.

\begin{defn}
Domeną akcji $\mathcal{D}$ nazywamy zbiór wszystkich zdań.
\end{defn}

Niech $\mathcal{D}$ - domena akcji, $\mathcal{S} = \left(\Sigma, \sigma_0, Res\right)$ - struktura języka.

Mówimy, że:
\begin{enumerate}
    \item fluent $f \in \mathcal{F}$  jest inercjalny w $\mathcal{S}$ wtedy i tylko wtedy, gdy $\left(\text{noninertial f}\right) \in \mathcal{D}$.
    \item $\sigma : \mathcal{F} \rightarrow \left\{0,1\right\}$ jest stanem $\mathcal{S}$ wtedy i tylko wtedy, gdy dla każdego ograniczenia $\left(\text{always } \alpha\right) \in \mathcal{D}$ zachodzi $\sigma \models \alpha$.
\end{enumerate}

% Stan, struktura - Maciek

% DNF - Jacek

\begin{defn}
Niech $\alpha$ będzie dowolną formułą nad zbiorem fluentów $\mathcal{F}$. Mówimy, że $\alpha$ jest w~\textbf{dysjunkcyjnej postaci normalnej (DNF)} wtedy i tylko wtedy, gdy 
$$\alpha = \bigvee_{i=1}^{n} \bigwedge_{j=1}^{k(i)} \lambda_{ij}$$
gdzie $\lambda_{ij}$ jest literałem.
\end{defn}

\begin{theorem}
Każdą formułę $\alpha$ można przekształcić do formuły $\alpha'$, która jest w postaci DNF.
\end{theorem}

Formułę $\alpha$ przekształconą do postaci DNF oznaczamy jako $DNF(\alpha)$.

\begin{defn}
Niech $DNF(\alpha) = \gamma_1 \vee \dots \vee \gamma_k$. Każdą formułę $\gamma_i$ nazywamy komponentem formuły $\alpha$.
\end{defn}

Metoda sprowadzania formuły do dysjunkcyjnej postaci normalnej:

\begin{enumerate}
	\item Eliminacja implikacji oraz równoważności, poprzez zastąpienie ich 			odpowiadającymi formułami 
		\begin{itemize}
			\item $\alpha \rightarrow \beta \equiv \neg\alpha \vee \beta$
			\item $\alpha \leftrightarrow \beta \equiv (\neg\alpha \vee \beta) \wedge (\neg\beta \vee \alpha)$
		\end{itemize}
	\item Przekształcenie formuły tak, aby negacje stały bezpośrednio przy odpowiadających im literałach
		\begin{itemize}
			\item $\neg(\alpha \wedge \beta) \equiv \neg\alpha \vee \neg\beta$
			\item $\neg(\alpha \vee \beta) \equiv \neg\alpha \wedge \neg\beta$
			\item $\neg\neg\alpha \equiv \alpha$
		\end{itemize}
		\item Rozdzielenie alternatywy względem koniunkcji
		\begin{itemize}
			\item $\alpha \wedge (\beta \vee \gamma) \equiv (\alpha \wedge \beta) \vee (\alpha \wedge \gamma)$
			\item $(\beta \vee \gamma) \wedge \alpha \equiv (\beta \wedge \alpha) \vee (\gamma \wedge \alpha)$
		\end{itemize}
\end{enumerate}

% dekompozycja, konflikt, Res0 - Filip

\begin{defn}
Niech $D$ to będzie domena akcji, niech $\sigma$ to będzie stan oraz niech $A, B \in \mathcal{AC}$ to dwie akcje elementarne. Akcje $A, B$ są konfliktujące wtedy i tylko wtedy gdy przynajmniej jeden z warunków jest prawdziwy:
\begin{itemize}
    \item Są w $D$ dwa zdania postaci:
    \begin{center}
        $A$ $\Causes$ $\alpha$ $\If$ $\pi_1 $ \\
        $B$ $\Causes$ $\beta$ $\If$ $\pi_2 $
    \end{center}
    takie, że:
    \begin{itemize}
        \item $\sigma \models \pi_1 \land \pi_2$
        \item Jakiś komponent z $\alpha$ jest sprzeczny z jakimś komponentem z $\beta$.
    \end{itemize}
    \item Są w $D$ dwa zdania postaci:
    \begin{center}
        $A$ $\Causes$ $\alpha$ $\If$ $\pi_1 $ \\
        $B$ $\Releases$ $f$ $\If$ $\pi_2 $
    \end{center}
    takie, że:
    \begin{itemize}
        \item $\sigma \models \pi_1 \land \pi_2$
        \item W jakimś komponencie z $\alpha$ występuje $f$.
    \end{itemize}
\end{itemize}
\end{defn}

\begin{defn}
Niech $D$ to będzie domena akcji, niech $\sigma$ to będzie stan. Akcja złożona $\{ A_1, \dots A_k \}$, gdzie $A_i$ to akcje elementarne, jest \textbf{potencjalnie wykonywalna} w $\sigma$ wtedy i tylko wtedy gdy nie istnieje $B \subseteq A_1 \cup \dots \cup A_k$ takie, że $D$ zawiera zdania:
\begin{center}
    $B$ $\Causes$ $\alpha_1$ $\If$ $\pi_1 $ \\
    $\cdots$ \\
    $B$ $\Causes$ $\alpha_k$ $\If$ $\pi_k $
\end{center}
takie, że:
\begin{itemize}
    \item $\sigma \models \pi_1 \land \dots \pi_k$
    \item $\alpha1 \land \dots \alpha_k$ jest sprzeczne
\end{itemize}
\end{defn}

\begin{defn}
Niech $D$ to będzie domena akcji, niech $\sigma$ to będzie stan oraz niech $A \subseteq \mathcal{AC}$. \textbf{Dekompozycją} $A$ w $\sigma$ będziemy nazywać będzie taki zbiór $\Delta(A, \sigma) = \{ E_1, E_2, \dots E_k \}$ akcji elementarnych w $D$, że:
\begin{enumerate}
    \item $\bigcup_{i = 1}^{k} E_i \subseteq A$
    \item  $\Delta(A, \sigma)$ jest zbiorem niekonfliktujących akcji potencjalnie wykonywalnych w  $\sigma$.
    \item Nie ma żadnego zbioru $\{ E_1^\prime \dots E_k^\prime, E_{k+1}^\prime, \dots, E_m^\prime \}$ akcji spełniającego powyższe warunki i w dodatku takiego, że $E_i \subset E_i^\prime$ dla pewnego $i = 1, \dots, k$.
\end{enumerate}
\end{defn}

\begin{defn}
Niech $\Delta(A, \sigma) = \{ E_1, E_2, \dots E_k \}$ będzie dekompozycją $A$ w $\sigma$, wtedy dla każdego $i$, $E_i$ jest nazywane \textbf{komponentem wykonania} $A$ w stanie $\sigma$.
\end{defn}

\begin{defn}
Niech $D$ to będzie domena akcji, niech $\sigma, \sigma^\prime$ to będą stany oraz niech $A \subseteq \mathcal{AC}$ to akcja i niech $\Delta(A, \sigma) = \{ E_1, E_2, \dots E_k \}$ to dekompozycja $A$ w $\sigma$. Mówimy, że $\sigma^\prime$ \textbf{potencjalnym wynikiem wykonania} $A$ w $\sigma$ wtedy i tylko wtedy gdy dla każdego $i = 1, \dots k$ i dla każdego zdania postaci: 
\begin{center}
    $(E_i \Causes \alpha \If \pi) \in D $
\end{center}
zachodzi, że $\sigma \models \pi \Rightarrow \sigma^\prime \models \alpha $
\end{defn} 

Oznacza to, że po wykonaniu $A$ w stanie $\sigma$ stan wynikowy to taki, który spełnia wszystkie efekty komponentów $E_i$ z jednej dekompozycji. Jeśli mamy $n$ różnych dekompozycji to potencjalny wynik akcji (stan po wykonaniu akcji) musi spełniać efekty tylko komponentów jednej z nich.

\begin{defn}
\textbf{Strukturą} dla $\mathcal{AC}$ jest taka trójka $(\Sigma, \sigma_0, Res)$, gdzie $\Sigma$ to zbiór stanów, $\sigma_0$ to stan początkowy i $Res: 2^{\mathcal{AC}} \times \Sigma \rightarrow 2^\Sigma$.

Dodatkowo definiowane jest mapowanie pomocnicze $Res_0: 2^{\mathcal{AC}} \times \Sigma \rightarrow 2^\Sigma$ w następujący sposób: dla każdego stanu $\sigma$ oraz dla każdej akcji $A \subseteq \mathcal{AC}$ zachodzi: jeśli $A$ posiada w $\sigma$ $n$ dekompozycji $\Delta_1(A, \sigma), \dots, \Delta_n(A, \sigma)$, gdzie $\Delta_i(A, \sigma) = \{ A_1^i, \dots, A_{k_i}^i \}$, to będzie zbiór wszystkich potencjalnych wyników wykonania $A$ w $\sigma$ dla każdej dekompozycji.
\end{defn}

% Mo d;del, funkcje psi - Michał

%Model
\begin{defn}

Niech $D$ będzie domeną akcji w $\mathcal{AC}$. Struktura $S = (\Sigma,\sigma_0,Res)$ jest \textbf{modelem D} wtw:
\begin{enumerate}
\item $\Sigma$ jest zbiorem wszystkich stanów w $D$ (tj. zbiorem wszystkich stanów satysfakcjonujących wszystkie ograniczenia z $D$);
\item każde zdanie wartości i każde zdanie obserwacji jest prawdziwe w $S$;
\item dla każdej akcji $A \subseteq \mathcal{A}c$ i dla każdego stanu $\sigma \in \Sigma$, $Res(A,\sigma) \subseteq Res_0(A,\sigma)$ jest zbiorem wszystkich stanów $\sigma'$, dla którego zbiory $New(A,\sigma,\sigma')$ są minimalne (mając na względzie zawierania się zbiorów)
%w oryginale powyższy fragment: "are minimal (wrt set inclusion)." wrt - with regards to, nie jestem pewien czy to dobrze przetłumaczyłem
\end{enumerate}
\end{defn}

%Funkcje psi

Niech $D$ będzie domeną akcji. Dla struktury $S = (\Sigma,\sigma_0,Res)$, definiujemy częściowe mapowanie 
$\Psi_S : 2^{\mathcal{A}c^*} \times \Sigma \rightarrow \Sigma$ w następujący sposób:
\begin{itemize}
\item $\Psi_S(\epsilon,\sigma) = \sigma$
\item jeśli dla $n \geq 1, \Psi_S((A_1,...,A_n),\sigma)$ jest zdefiniowane i $Res((A_1,...,A_n,A_{n+1}),\sigma) \neq \emptyset$, to $\Psi_S((A_1,...,A_n,A_{n+1}),\sigma) \in Res(A_n,\Psi_S((A_1,...,A_n),\sigma)).$
\end{itemize}

\section{Język kwerend}

\subsection{Składnia języka}

    \textbf{Kwerendą} będziemy nazywać jedno z~następujących wyrażeń:

    \begin{enumerate}
        \item Kwerendy wartości:
        \begin{itemize}            
            \item $\Possibly \gamma \After A_1, \dots, A_n$ -- określa, czy wykonanie programu $(A_1, \dots, A_n)$ ze~stanu początkowego prowadzi kiedykolwiek do~osiągnięcia celu~$\gamma$,
            \item $\Necessary \gamma \After A_1, \dots, A_n$ -- określa, czy wykonanie programu $(A_1, \dots, A_n)$ ze~stanu początkowego zawsze prowadzi do~osiągnięciu celu~$\gamma$,
        \end{itemize}
        \item Kwerendy wykonywalności:
        \begin{itemize}
            \item $\Executable A_1, \dots, A_n$ -- określa, czy program $(A_1, \dots, A_n)$ jest kiedykolwiek wykonywalny ze~stanu początkowego,
            \item $\Executable \Always A_1, \dots, A_n$ -- określa, czy program $(A_1, \dots, A_n)$ jest zawsze wykonywalny ze~stanu początkowego,
        \end{itemize}
        gdzie $A_1, \dots, A_n \subseteq \mathcal{A}c$.
        \item Kwerendy osiągalności:
        \begin{itemize}
            \item $\Accessible \gamma$ -- określa, czy~istnieje taki program $(A_1, \dots, A_n)$, $n \geq 0$ wykonywalny ze~stanu początkowego, po~którego wykonaniu osiągnięty zostanie cel~$\gamma$.
        \end{itemize}
        gdzie $\gamma \in Forms(f)$, $A_1, \dots, A_n \subseteq \mathcal{A}c$.
    \end{enumerate}


\subsection{Semantyka języka}

    Niech $\mathcal{D}$ będzie domeną akcji, a $\mathcal{Q}$ kwerendą. % TODO: dopisać jakiego języka?
    Mówimy, że $\mathcal{Q}$ jest \textbf{konsekwencją} $\mathcal{D}$ (ozn. $\mathcal{D} \consequence \mathcal{Q}$), jeżeli:

    \begin{enumerate}
        \item w przypadku gdy $\mathcal{Q}$ jest kwerendą wartości postaci:
        \begin{itemize}
            \item $\Possibly \gamma \After A_1, \dots, A_n$ -- wówczas $\mathcal{D} \consequence \mathcal{Q}$ wtedy i tylko wtedy, gdy dla każdego modelu % TODO: do uzgodnienia
            $\mathcal{S} = (\Sigma,\sigma_0,Res)$ domeny akcji $\mathcal{D}$ istnieje mapowanie $\Psi_S$ takie, że zachodzi $\Psi_S((A_1,...,A_n),\sigma_{0}) \models \gamma$,
            \item $\Necessary \gamma \After A_1, \dots, A_n$ -- wówczas $\mathcal{D} \consequence \mathcal{Q}$ wtedy i tylko wtedy, gdy dla każdego modelu % TODO: do uzgodnienia
            $\mathcal{S} = (\Sigma,\sigma_0,Res)$ domeny akcji $\mathcal{D}$, dla każdego mapowania $\Psi_S$ zachodzi $\Psi_S((A_1,...,A_n),\sigma_{0}) \models \gamma$,
        \end{itemize}
        \item w przypadku gdy $\mathcal{Q}$ jest kwerendą wykonywalności postaci:
        \begin{itemize}
            \item $\Executable A_1, \dots, A_n$ -- wówczas $\mathcal{D} \consequence \mathcal{Q}$ wtedy i tylko wtedy, gdy istnieje model % TODO: do uzgodnienia
            $\mathcal{S} = (\Sigma,\sigma_0,Res)$ domeny akcji $\mathcal{D}$ taki, że istnieje % TODO: do uzgodnienia
            mapowanie $\Psi_S$ takie, że $\Psi_S((A_1,...,A_n),\sigma_{0})$ jest zdefiniowane,
            \item $\Executable \Always A_1, \dots, A_n$ -- wówczas $\mathcal{D} \consequence \mathcal{Q}$ wtedy i tylko wtedy, gdy dla każdego modelu % TODO: do uzgodnienia
            $\mathcal{S} = (\Sigma,\sigma_0,Res)$ domeny akcji $\mathcal{D}$, dla każdego mapowania $\Psi_S$ $\Psi_S((A_1,...,A_n),\sigma_{0})$ jest zdefiniowane,
        \end{itemize}
        \item w przypadku gdy $\mathcal{Q}$ jest kwerendą osiągalności postaci:
        \begin{itemize}
            \item $\Accessible \gamma$ -- wówczas $\mathcal{D} \consequence \mathcal{Q}$ wtedy i tylko wtedy, gdy dla każdego modelu $\mathcal{S} = (\Sigma,\sigma_0,Res)$ domeny akcji $\mathcal{D}$, dla każdego mapowania $\Psi_S$ istnieje ciąg akcji $(A_1,...,A_n), \; n \geq 0$ taki, że:
            \begin{itemize}
                \item $\Psi_S((A_1,...,A_n),\sigma_{0})$ jest zdefiniowane,
                \item $\Psi_S((A_1,...,A_n),\sigma_{0}) \models \gamma$.
            \end{itemize}
        \end{itemize}
    \end{enumerate}

% kwerendy - Tymek

\section{Przykładowe kwerendy}

% przykłady - ja

\end{document}